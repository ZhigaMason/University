---
title: "notebook"
output: html_document
authors:
    - Oleksand Slyvka
    - Illia Lyhin
    - Maksym Khavil
date: "2025-04-30"
---

We have chosen Oleksandr Slyvka as our representative, his M value is 6. This gives us year 2018 to analyse.

## Libraries

```{r setup, include=TRUE}
library(eurostat)
library(ggplot2)
library(cowplot)
library(corrplot)
library(vtable)
library(grid)
library(sf)
library(dplyr)
library(rnaturalearth)
# remotes::install_github("ropensci/rnaturalearthhires")
library(rnaturalearthhires)
library(countrycode)
library(car)
library(lmtest)
```

## Importing & Explaining Average Salary

```{r}
data <- get_eurostat("nama_10_fte", time_format = "num")
data <- data[(data$unit == "EUR") & (data$TIME_PERIOD == 2018),]
data <- data[c("geo", "values")]
data
```

Our data includes records for *Euro Area (EA20)* and *European Union (EU27_2020)*, more over those are records that had not came from year 2018. Those are not standalone countries, so we better delete them. Also it uses *EL* for Greece (Ellada), we will rename it. Also we have no possession of a record for Netherlands.

Lastly we will replace country codes with country names.

```{r}
data <- data[(data$geo != "EA20") & (data$geo != "EU27_2020"),]
data[(data$geo == "EL"), "geo"] <- "GR"
data$geo <- countrycode(data$geo, origin = 'iso2c', destination = 'country.name')
data
```

Let us define a generic function that will help us display data on a map of European Union.

```{r warning=FALSE}
world_map <- ne_countries(scale = "large", returnclass = 'sf')
europe_bbox <- st_bbox(c(xmin = -20, xmax = 40, ymax = 75, ymin = 30), crs = st_crs(4326))
eu_map <- world_map %>% filter(name %in% data$geo) %>%  st_crop(europe_bbox)

plot_eu <- function(mydata, col, by_data="geo", by_map="name") {
    disp <- left_join(eu_map, mydata, by = setNames(by_data, by_map))
    return (ggplot(disp) +  geom_sf(aes(fill=.data[[col]])) + theme_minimal())
}
```

Now we will take a look at a map with **Average Salaries**, histogram of the variable and summary of mean, standard deviation, limits, quartilse and IQR.

```{r}
plot_eu(data, "values") +
    scale_fill_viridis_c(
      name="Average Salary", 
      guide = guide_colorbar(barheight = 15, barwidth = 1),
      breaks=10000*(1:6)
    )

summ <- c('mean(x)', 'sd(x)', 'min(x)', 'pctile(x)[25]',
          'median(x)', 'pctile(x)[75]', 'max(x)', 'IQR(x)'
)

hist(data$values, main="Histogram of Average Salary", col="cyan")

sumtable(
  data, 'values',
  out='kable',
  summ=summ
)

data %>% slice_max(order_by = values, n = 7)
```

We can see that employees in countries on the east are generally paid less, histogram agrees with map in spike of 10-20k euros, very similiar to what we see on the map. Mean is 28k euros, while median is only 22k, so we might expect that there are some countries where employees are paid a lot higher. Our last plot shows that those countries are **Luxemburg** and **Denmark**, first one is famous for its banks and Denmark is known to be a money harbor for its stability and location.

## Regressors' Descriptions

### Distance to Voronezh

Our first regressor will be a distance between country's capital and city of Voronezh. We expect it to positively correlate with **Average Salary**. To construct such feature we would firstly get coordinates of each country's capital.

```{r}
# Load populated places, including capitals
places <- ne_download(scale = "small", type = "populated_places", category = "cultural", returnclass = "sf")
capitals <- places %>%
  filter(FEATURECLA == "Admin-0 capital", ADM0NAME %in% data$geo)

# View capital names and coordinates
capital_coords <- capitals %>% select(name = NAME, country = ADM0NAME, geometry)

capital_coords <- capital_coords %>%
  mutate(
    lon = st_coordinates(geometry)[, 1],
    lat = st_coordinates(geometry)[, 2]
  )
```

With coordinates on our hand we will compute the distance using `st_distance` function from `sf`. This implementation accounts for Earth's curvature and computes spherical distance.

```{r}
points <- st_as_sf(capital_coords, capital_coords = c("lon", "lat"), crs = 4326)

voronezh <- st_sfc(st_point(c(51.67204, 39.1843)), crs = 4326)

points$distance_to_voronezh <- as.numeric(st_distance(points, voronezh)) / 1000
points <- as.data.frame(points)[c("country", "distance_to_voronezh")]
points
data <- left_join(data, points, by=setNames("country","geo"))
data
```

Let us do a quick data analysis of the variable. This will include drawing a map of it, its histogram, basic descriptive statistics and a scatter plot against **Average Salary**.

```{r}
plot_eu(data, "distance_to_voronezh") +
    scale_fill_gradient(
        name = "Distance to voronezh (km)",
        low = "black", high = "white" 
    ) +
    guides(fill = guide_colorbar(barwidth = 1, barheight = 15))

hist(
    data$distance_to_voronezh, 
    main="Histogram of distance to Voronezh (km)",
    xlab="distance to Voronezh (km)",
    col="gray",
    breaks=1000 * (1:6)
)

plot(
    data$distance_to_voronezh, data$values,
    main=sprintf("Distance to Voronezh (km) X Average Salary (r=%.2f)", cor(data$distance_to_voronezh, data$values)),
    xlab="Distance to Voronezh (km)",
    ylab="Average Salary",
    col="black", pch=19
)

sumtable(
  data, 'distance_to_voronezh',
  out='kable',
  summ=summ,
  factor.numeric = TRUE
)
```

This variable is purely geographical, so we obtain a white-to-black gradient spanning all Europe. Histograms is skewed to the left, it is a result of greater number of countries located on the east of EU. As we have expected **Distance to Voronezh** correlates positively with **Average Salary**, Pearson's coefficient is not large (less than 0.5), but it shows a connection, that the further away a country is from Voronezh, the higher Salary can be expected. Lastly, descriptive statistics agree with an observation about histogram and show a mean of $3200$ and standard deviation of $776$ kilometers.

### Illia Lyhin's preference to visit named country for a leisure week (on 01.05.2018 at 16:00)

Illia Lyhin, being one of the authors of this project, is a stellar traveller, so surely he has an opinion whether he wants to visit a country or not. We assume it is a good indication about country's **Average Salary**, as Lyhin is rarely happens to be wrong about topics touching monetary relationship. Below we present his view.

```{r}
lyhin_lvls = c("Low", "Medium", "High")

data$lyhin_preference = "Medium"
data[data$geo %in% c("Austria", "Cyprus", "Czechia", "Denmark", "Ireland", "Portugal"),]$lyhin_preference = "High"
data[data$geo %in% c("Belgium", "Bulgaria", "Hungary", "Romania", "Slovakia", "Lithuania", "Latvia"),]$lyhin_preference = "Low"
data$lyhin_preference <- factor(data$lyhin_preference, levels=lyhin_lvls, ordered=TRUE)
data
```

With data on our hands let us plot it.

```{r}

color.low = "#EFEA90"
color.mid = "#DFD420"
color.hig = "#B6AC1A"

plot_eu(data, "lyhin_preference") +
  scale_fill_manual(
    name = "Illia Lyhin's Preference",
    values = c(
      "Low" = color.low,
      "Medium" = color.mid,
      "High" = color.hig
    )
  )

par(mar = c(5, 4, 4, 8), xpd = TRUE)
boxplot(
    values ~ lyhin_preference, data=data,
    main="Average Salary by Illia Lyhin's Preference",
    ylab="Average Salary",
    xlab="Illia Lyhin's Preference",
    col=c(color.low, color.mid, color.hig)
)

data %>%
  group_by(lyhin_preference) %>%
  summarise(
    count = n(),
    mean = mean(values),
    sd = sd(values),
    min = min(values),
    median=median(values),
    max = max(values)
  )
```

There is nothing to note about individual records, except excellent choices for a vacation. Box plots show that low priority countries have, indeed, lower **Average Salary**, though there is a flyer, which must be Belgium. Medium and high priority countries behave very similarly. High has a larger spread with standard deviation of $18.5k$ euros.

### Number of people in penitentiary system

One could hypothesis that **Average Salary** is a measure of stability and well-being. Number of people in penitentiary system can be another measure of those qualities. It is usually expected that prosperous countries have less crime, so prisons are not as filled as ones in developing countries. We will use [crim_pris_age](https://ec.europa.eu/eurostat/databrowser/view/CRIM_PRIS_AGE/default/table?lang=en&category=crim.crim_pris) Eurostat dataset for this data, it provides more data than we need so we will selected rows that we need. Criteria are year 2018 and total population (both in terms of sex and age). We also can choose between different units, we have decided on "Per hundred thousands inhabitants", because it is a relative measure, so it is adequate to compare it between different countries. We expect **Prisoners per 100K** to negatively correlate with **Average Salary**.

```{r warning=FALSE}
crim <- get_eurostat("crim_pris_age")
crim <- crim[(crim$age == "TOTAL") & (crim$sex == "T") & (as.Date('2018-01-01') <= crim$TIME_PERIOD) & (crim$TIME_PERIOD < as.Date('2019-01-01')) & (crim$unit == "P_HTHAB"),]
crim[(crim$geo == "EL"), "geo"] <- "GR"
crim$geo <- countrycode(crim$geo, origin = 'iso2c', destination = 'country.name')
crim <- crim[c("geo", "values")] %>% rename(prisoners_per_100K=values)
data <- left_join(data, crim, by="geo")
data
```

We will conduct the same data analysis for **Prisoners per 100K** as we have done for **Distance to Voronezh**.

```{r}
plot_eu(data, "prisoners_per_100K") +
    scale_fill_gradient(
        name = "Prisoners per 100K",
        low = "white", high = "red" 
    ) +
    guides(fill = guide_colorbar(barwidth = 1, barheight = 15))

hist(data$prisoners_per_100K, main="Histogram of Prisoners per 100K", col="red", xlab="Prisoners per 100K")

plot(
    data$prisoners_per_100K, data$values,
    main=sprintf("Prisoners per 100K X Average Salary (r=%.2f)", cor(data$prisoners_per_100K, data$values)),
    xlab="Prisoners per 100K",
    ylab="Average Salary",
    col="red", pch=19
)

sumtable(
  data, 'prisoners_per_100K',
  out='kable',
  summ=summ,
  factor.numeric = TRUE
)
```
Number of prisoners is much higher in eastern countries. As a result distribution is skewed left with mean $120$, median $104$ and standard deviation of $51$ prisoners per hundred thousands inhabitants.

### Most Profitable NACEr2 A10 Cateogry

We will use one more categorical feature, the most profitable NACEr2 A10 category. It must differentiate differently structured economies, as different countries have different sources of profit. For that we will use [nama_10_a10](https://ec.europa.eu/eurostat/databrowser/view/nama_10_a10/default/table?lang=en) Eurostat dataset. Categories presented in this dataset are not disjoint, but we will categories that are a part of a bigger union of sectors. As a unit of measure we will use Percents of GDP to stay relative to countries' scale.

```{r}
nace <- get_eurostat("nama_10_a10", select_time="A")
nace2 <- nace[(nace$na_item == "B1G") & (as.Date('2018-01-01') <= nace$TIME_PERIOD) & (nace$TIME_PERIOD < as.Date('2019-01-01')) & (nace$unit == "PC_GDP"),]
nace2 <- nace2 %>% filter(nace_r2 != "TOTAL")
nace2 <- nace2 %>%
  mutate(nace_r2_sector = dplyr::recode(nace_r2,
    "A"   = "Agriculture, forestry and fishing",
    "B-E" = "Industry",
    "F"   = "Construction",
    "G-I" = "Wholesale, retail, transport, accommodation",
    "J"   = "Information and communication",
    "K"   = "Financial and insurance activities",
    "L"   = "Real estate activities",
    "M-N" = "Professional & admin services",
    "O-Q" = "Public administration, education, health",
    "R-U" = "Arts, entertainment, other services"
  ))
nace2 <- nace2 %>% group_by(geo) %>% top_n(1,values) %>% select(geo, nace_r2_sector)
nace2[(nace2$geo == "EL"), "geo"] <- "GR"
nace2$geo <- countrycode(nace2$geo, origin = 'iso2c', destination = 'country.name')
data <- left_join(data, nace2, by="geo")
nace_r2_lvls =sort(unique(data$nace_r2_sector))
data$nace_r2_sector <- factor(data$nace_r2_sector, levels=nace_r2_lvls, ordered = FALSE)
unique(data$nace_r2)
data
```

Let us now display those classes and **Average Salary** in them.

```{r}
color.fin = "#E77D88"
color.ind = "#BDE77D"
color.pub = "#7DE7DC"
color.ret = "#A77DE7"

plot_eu(data, "nace_r2_sector") +
  scale_fill_manual(
    name = "Most Profitable NACE2 A10 Categories",
    values = c(
      "Financial and insurance activities" = color.fin,
      "Industry" = color.ind,
      "Public administration, education, health" = color.pub,
      "Wholesale, retail, transport, accommodation" = color.ret
    )
  )

data.nace2.fin = data[data$nace_r2_sector == "Financial and insurance activities",]
data.nace2.ind = data[data$nace_r2_sector == "Industry",]
data.nace2.pub = data[data$nace_r2_sector == "Public administration, education, health",]
data.nace2.ret = data[data$nace_r2_sector == "Wholesale, retail, transport, accommodation",]

par(mar = c(5, 4, 4, 8), xpd = TRUE)
boxplot(
    values ~ nace_r2_sector, data=data,
    col=c(color.fin, color.ind, color.pub, color.ret),
    main="Average Salary by Most Profitable NACE2 A10 Categories",
    ylab="Average Salary",
    xaxt='n'
)

legend(
    "topright", inset=c(-0.2, 0),
    legend = c("Finance", "Industry", "Administration", "Wholesale"), 
    fill = c(color.fin, color.ind, color.pub, color.ret), 
    title = "NACE2 A10 Categories"
)

data %>%
  group_by(nace_r2_sector) %>%
  summarise(
    count = n(),
    mean = mean(values),
    sd = sd(values),
    min = min(values),
    median=median(values),
    max = max(values)
  )
```

Most of countries fall into 3 categories *Industry*, *Administration* and *Wholesale* with Luxemburg lonely holding to *Finance*. This leads to a flattened boxplot of **Finance**. Pooled average of *Administration* is the highest with *Industry* coming second and *Wholesale* coming last. *Industry* sector also shows the biggest spread with standard deviation of $16k$ euros.

### Daily Internet Use (%)

Our fifth feature is **Daily Internet Use** coming from Eurostat dataset [isoc_ci_ifp_fu](https://ec.europa.eu/eurostat/databrowser/view/isoc_ci_ifp_fu/default/table?lang=en). We have no expectation for this variable to be related to **Average Salary**, because internet connection is both cheap and wide spread.

```{r}
ifp <- get_eurostat("isoc_ci_ifp_fu")
ifp <- ifp[(as.Date('2018-01-01') <= ifp$TIME_PERIOD) & (ifp$TIME_PERIOD < as.Date('2019-01-01')) & (ifp$unit == "PC_IND") & (ifp$indic_is == "I_IDAY") & (ifp$ind_type == "IND_TOTAL"),]
ifp[(ifp$geo == "EL"), "geo"] <- "GR"
ifp$geo <- countrycode(ifp$geo, origin = 'iso2c', destination = 'country.name')
ifp <- ifp[c("geo", "values")] %>% rename(daily_internet_usage_pc=values)
data <- left_join(data, ifp, by="geo")
data
```

```{r}
plot_eu(data, "daily_internet_usage_pc") +
    scale_fill_gradient(
        name = "Daily Internet Usage (%)",
        low = "cyan", high = "darkgreen" 
    ) +
    guides(fill = guide_colorbar(barwidth = 1, barheight = 15))

hist(
    data$daily_internet_usage_pc, 
    main="Histogrma of Daily Internet Usage (%)", 
    col="darkgreen", 
    xlab="Daily Internet Usage (%)",
    breaks=(10 * (0:5)) + 50
)

plot(
    data$daily_internet_usage_pc, data$values,
    main=sprintf("Daily Internet Usage (%%) X Average Salary (r=%.2f)", cor(data$daily_internet_usage_pc, data$values)),
    xlab="Daily Internet Usage (%)",
    ylab="Average Salary",
    col="darkgreen", pch=19
)

sumtable(
  data, 'daily_internet_usage_pc',
  out='kable',
  summ=summ,
  factor.numeric = TRUE
)
```

**Daily Internet Usage** has a normal-looking distribution with heart of online activity at Denmark. Surprisingly internet usage has strong positive linear correlation with **Average Salary**.

Let us take a look at the data on our hands and proceed to investigate dependency between regressors.
```{r}
data
```

### Testing Independance of Regressor

I dont know what does it mean, like should we do $\chi^2$ test or smth

## Modeling

```{r}
full_model <- lm(values ~ distance_to_voronezh + lyhin_preference + prisoners_per_100K + nace_r2_sector + daily_internet_usage_pc, data=data)
summary(full_model)
print(sprintf("RMSE of model: %.2f", sqrt(mean(full_model$residuals ^ 2))))
```

yap about individual regressors & R2-adj

## Outliers

```{r warning=FALSE}
plot(full_model, which=4)
plot(full_model, which=5)
largest_cookd <-  data[c(4, 5, 22),]
largest_cookd$modeled_values <-  predict(full_model, newdata=largest_cookd)
largest_cookd <- largest_cookd[c("geo", "values", "modeled_values")]
largest_cookd
```

yap about how portugal can suck deez nuts for bein a fking flyer

### Multicolinearity

```{r}
vif(full_model, type = "predictor")
```

yap about no colinearity due to low adjusted GVIF

### Homoscedasticity

```{r}
plot(full_model, which=3)
bptest(full_model)
largest_scale <-  data[c(5, 22, 1),]
largest_scale$modeled_values <-  predict(full_model, newdata=largest_scale)
largest_scale <- largest_scale[c("geo", "values", "modeled_values")]
largest_scale
```

yap about how we actually pass test on 5% confidence level.

### Normality of Residuals


```{r warning=F}
plot(full_model, which=1)
plot(full_model, which=2)
shapiro.test(full_model$residuals)
```
yap about good f-ing residuals

### Choosing submodel

```{r}
step(lm(values ~ 1, data = data), 
     scope = list(lower = ~ 1, upper = ~ distance_to_voronezh + lyhin_preference + prisoners_per_100K + nace_r2_sector + daily_internet_usage_pc), 
     direction = "both", 
     data = data)
```

yap about exclusion of Illia's preferance <!-- https://tenor.com/view/disintegrating-aughhh-gif-24532719 -->

```{r}
submodel <- lm(formula = values ~ daily_internet_usage_pc + prisoners_per_100K +  nace_r2_sector + distance_to_voronezh, data = data)
summary(submodel)
print(sprintf("RMSE of model: %.2f", sqrt(mean(submodel$residuals ^ 2))))
```

yap about lower variance & shitty intercept (fing luxemburg and bulgaria)

```{r}
anova(submodel, full_model)
```

yap about how fing great our model is

## Conclusion

YAP